var EventEmitter, ParX, Q, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

_ = require('lodash');

Q = require('q');

EventEmitter = require("events").EventEmitter;


/*
Public: Executes tasks in parallel.
 */

ParX = (function(_super) {
  __extends(ParX, _super);

  Object.defineProperty(ParX.prototype, 'all', {
    get: function() {
      return this.allTasks;
    }
  });

  function ParX(opts) {
    if (opts == null) {
      opts = {};
    }
    this.abort = __bind(this.abort, this);
    this.add = __bind(this.add, this);
    this.start = __bind(this.start, this);
    this.manual = opts.manual || false;
    if (opts.context != null) {
      this.context = opts.context;
    }
    this.taskList = [];
    this._abort = false;
    this.count = 0;
    this.allTasks = Q(true);
    this.start();
  }

  ParX.prototype.start = function() {
    if (this.started) {
      return;
    }
    this.started = true;
    return this.emit('start');
  };

  ParX.prototype.add = function() {
    var f, list, tasks, wrap;
    list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    wrap = (function(_this) {
      return function(fn) {
        var id, x;
        id = _this.count++;
        x = Q.fcall(fn, id, _this.context);
        x.then(function(res) {
          return _this.emit('completed', res, id, _this.context);
        });
        _this.emit('task', fn);
        return x;
      };
    })(this);
    list = _.flattenDeep([list]);
    tasks = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        f = list[_i];
        _results.push(wrap(f));
      }
      return _results;
    })();
    tasks.push(this.allTasks);
    return this.allTasks = Q.all(tasks);
  };

  ParX.prototype.abort = function() {
    this._abort = true;
    return this.emit('abort');
  };

  return ParX;

})(EventEmitter);

module.exports = ParX;
