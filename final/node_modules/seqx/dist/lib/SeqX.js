var EventEmitter, Q, SeqX,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

Q = require('q');

EventEmitter = require("events").EventEmitter;


/*
Public: {SeqX} Execute tasks sequentially.

Result of a task is passed to the next. Returns promises which resolve
when tasks are completed. Fires events when tasks are completed.

 * Events

 *# start
Public: Fired when task execution begins.

 *# task
Public: Fired when a new task is added.
* `fn` {Function} the task which was added.

 *# completed
Public: Fired when a  task is completed. Callback receives the result of the
 task, the task id and the context, if any.

* `result` the result of the previous task, if any
* `id` {Int} the task's id
* `context` (optional) context {Object} given when the executor was created

 *# abort
Public: Fired if `abort()` is called on the executor.


 * Tasks
Tasks are functions. A task can receive one or more arguments, in
  the following order:

1. `result` The result from the previous task. Can be `undefined`.
2. `id` The task's id which is an incrementing counter.
3. `context` An optional context object which is was supplied when the
  executor was created.

```javascript
function task(result, id, context) {
  return valueForNextTask;
 }
```
 */

SeqX = (function(_super) {
  __extends(SeqX, _super);

  function SeqX(opts) {
    if (opts == null) {
      opts = {};
    }
    this.actualAdd = __bind(this.actualAdd, this);
    this.abort = __bind(this.abort, this);
    this.addn = __bind(this.addn, this);
    this.add = __bind(this.add, this);
    this.start = __bind(this.start, this);
    this.manual = opts.manual || false;
    if (opts.context != null) {
      this.context = opts.context;
    }
    this.initial = Q.defer();
    this.task = this.initial.promise;
    this.started = false;
    this.taskQueue = [];
    this._abort = false;
    this.count = 0;
    if (!this.manual) {
      this.start();
    }
  }

  SeqX.prototype.start = function() {
    if (this.started) {
      return;
    }
    this.started = true;
    this.initial.resolve(true);
    return this.emit('start');
  };

  SeqX.prototype.add = function() {
    var f, fn, _i, _len;
    fn = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = fn.length; _i < _len; _i++) {
      f = fn[_i];
      this.actualAdd(f);
    }
    return this.task;
  };

  SeqX.prototype.addn = function(fn, n) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.actualAdd(fn);
    }
    return this.task;
  };

  SeqX.prototype.abort = function() {
    this._abort = true;
    return this.emit('abort');
  };

  SeqX.prototype.actualAdd = function(fn) {
    var f;
    f = (function(_this) {
      return function(args) {
        var id, x;
        id = _this.count++;
        x = Q.fcall(fn, args, id, _this.context);
        x.then(function(res) {
          return _this.emit('completed', res, id, _this.context);
        });
        return x;
      };
    })(this);
    this.task = this.task.then((function(_this) {
      return function(args) {
        if (_this._abort) {
          throw new Error('Aborted by user');
        }
        return f(args);
      };
    })(this));
    return this.emit('task', fn);
  };

  return SeqX;

})(EventEmitter);

module.exports = SeqX;
