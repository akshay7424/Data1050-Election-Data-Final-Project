var EventEmitter, LoadingCache, Meta, Stats, flatten, millisecond, moment, prop, seqx,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

EventEmitter = require('events').EventEmitter;

prop = require('prop-it');

millisecond = require('millisecond');

Stats = require('./Stats');

moment = require('moment');

seqx = require('seqx');

flatten = require('flatten');

Meta = (function() {
  function Meta() {
    this.use = bind(this.use, this);
    this.diff = bind(this.diff, this);
    this._insertedAt = this._lastUsedAt = moment();
    this._useCount = 0;
  }

  Meta.prototype.diff = function(now) {
    return now.diff(this._insertedAt);
  };

  Meta.prototype.use = function() {
    this._lastUsedAt = moment();
    return this._useCount++;
  };

  return Meta;

})();

module.exports = LoadingCache = (function(superClass) {
  extend(LoadingCache, superClass);

  function LoadingCache(opts) {
    var expiry, ref, ref1;
    if (opts == null) {
      opts = {};
    }
    this._remove = bind(this._remove, this);
    this._findFirstWith = bind(this._findFirstWith, this);
    this._findExpiredKeys = bind(this._findExpiredKeys, this);
    this._evictByTime = bind(this._evictByTime, this);
    this._evictBySize = bind(this._evictBySize, this);
    this._refresh = bind(this._refresh, this);
    this._keys = bind(this._keys, this);
    this.set = bind(this.set, this);
    this.get = bind(this.get, this);
    this.refresh = bind(this.refresh, this);
    this.cleanup = bind(this.cleanup, this);
    this.deleteAll = bind(this.deleteAll, this);
    this.size = bind(this.size, this);
    this.has = bind(this.has, this);
    expiry = (ref = opts.expiry) != null ? ref : '1h';
    this._cache = new Map();
    this._stats = new Stats();
    this._ex = seqx();
    prop(this, {
      name: 'expiry',
      convert: millisecond,
      initial: expiry
    });
    prop(this, {
      name: 'maxSize',
      initial: (ref1 = opts.maxSize) != null ? ref1 : 1000
    });
    prop(this, {
      name: 'stats',
      getter: (function(_this) {
        return function() {
          return _this._stats.toObject();
        };
      })(this)
    });
    prop(this, {
      name: 'loader'
    });
  }

  LoadingCache.prototype.has = function(k) {
    return this._cache.has(k);
  };

  LoadingCache.prototype.size = function() {
    return this._cache.size;
  };

  LoadingCache.prototype["delete"] = function(k) {
    return this._remove(k, 'explicit');
  };

  LoadingCache.prototype.deleteAll = function() {
    var j, k, keys, len, results;
    keys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    keys = flatten(keys);
    if (keys.length === 0) {
      keys = this._keys();
    }
    results = [];
    for (j = 0, len = keys.length; j < len; j++) {
      k = keys[j];
      results.push(this["delete"](k));
    }
    return results;
  };

  LoadingCache.prototype.cleanup = function() {
    return this._ex.add(this._evictBySize, this._evictByTime);
  };

  LoadingCache.prototype.refresh = function(k) {
    return this._ex.add(this._refresh(k));
  };

  LoadingCache.prototype.get = function(k, loader) {
    var now, v;
    if (this.has(k)) {
      v = this._cache.get(k);
      now = moment();
      if (v.meta.diff(now) <= this.expiry()) {
        this._stats.hit();
        v.meta.use();
        return v.data;
      }
      this._remove(k, 'expiry');
    }
    this._stats.miss();
    return this._refresh(k, loader);
  };

  LoadingCache.prototype.set = function(k, v) {
    this._cache.set(k, {
      data: v,
      meta: new Meta()
    });
    this.emit('set', k, v);
    this._ex.add(this._evictBySize());
    return this;
  };

  LoadingCache.prototype._keys = function() {
    return this._findFirstWith(function() {
      return true;
    });
  };

  LoadingCache.prototype._refresh = function(k, loader) {
    var err, error, load, ref, v;
    if (!(loader != null ? loader : loader = this._loader)) {
      return;
    }
    load = (ref = loader.load) != null ? ref : loader;
    try {
      v = load(k);
      this.set(k, v);
      this._stats.loadOk();
      return v;
    } catch (error) {
      err = error;
      this._stats.loadError();
      return this.emit('error', err);
    }
  };

  LoadingCache.prototype._evictBySize = function() {
    var i, iter, j, k, keys, len, n, results;
    if (this.size() <= this.maxSize()) {
      return;
    }
    n = this.size() - this.maxSize();
    iter = this._cache.keys();
    keys = (function() {
      var j, ref, results;
      results = [];
      for (i = j = 0, ref = n - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(iter.next().value);
      }
      return results;
    })();
    results = [];
    for (j = 0, len = keys.length; j < len; j++) {
      k = keys[j];
      this._remove(k, 'size');
      results.push(this._stats.evict());
    }
    return results;
  };

  LoadingCache.prototype._evictByTime = function() {
    var j, k, len, ref, results;
    ref = this._findExpiredKeys(moment());
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      k = ref[j];
      this._remove(k, 'expiry');
      results.push(this._stats.evict());
    }
    return results;
  };

  LoadingCache.prototype._findExpiredKeys = function(now) {
    var expiry;
    expiry = this.expiry();
    return this._findFirstWith(function(k, v) {
      return v.meta.diff(now) > expiry;
    });
  };

  LoadingCache.prototype._findFirstWith = function(fn) {
    var iter, k, keys;
    keys = [];
    iter = this._cache.keys();
    while (k = iter.next().value) {
      if (!fn(k, this._cache.get(k))) {
        break;
      }
      keys.push(k);
    }
    return keys;
  };

  LoadingCache.prototype._remove = function(k, reason) {
    var v;
    if (!this.has(k)) {
      return;
    }
    v = this._cache.get(k).data;
    this._cache["delete"](k);
    this.emit('delete', k, v, reason);
    return this;
  };

  return LoadingCache;

})(EventEmitter);
